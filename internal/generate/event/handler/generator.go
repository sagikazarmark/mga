package handler

import (
	"bytes"
	"go/format"

	"github.com/dave/jennifer/jen"

	"sagikazarmark.dev/mga/pkg/gentypes"
)

// File provides information for generating event handlers.
type File struct {
	gentypes.File

	// EventHandlers represents event handlers to be generated for matching events.
	EventHandlers []EventHandler
}

// EventDispatcher describes an event handler.
type EventHandler struct {
	Name  string
	Event gentypes.TypeRef
}

// Generate generates an event handler.
func Generate(file File) ([]byte, error) {
	code := jen.NewFilePathName(file.Package.Path, file.Package.Name)

	code.HeaderComment("//go:build !ignore_autogenerated\n// +build !ignore_autogenerated\n")

	if file.HeaderText != "" {
		code.HeaderComment(file.HeaderText)
	}

	code.HeaderComment("Code generated by mga tool. DO NOT EDIT.")

	code.ImportName("emperror.dev/errors", "errors")

	for _, eventHandler := range file.EventHandlers {
		generateEventHandler(code, eventHandler)
	}

	var buf bytes.Buffer

	err := code.Render(&buf)
	if err != nil {
		return nil, err
	}

	return format.Source(buf.Bytes())
}

func generateEventHandler(code *jen.File, eventHandler EventHandler) {
	handlerTypeName := eventHandler.Name + "Handler"
	eventHandlerTypeName := eventHandler.Name + "EventHandler"

	const (
		handlerVarName     = "handler"
		handlerNameVarName = "name"
	)

	code.ImportName(eventHandler.Event.Package.Path, eventHandler.Event.Package.Name)

	code.Commentf("%s handles %s events.", handlerTypeName, eventHandler.Name)
	code.Type().Id(handlerTypeName).Interface(
		jen.Commentf("%s handles a(n) %s event.", eventHandler.Name, eventHandler.Name),
		jen.Id(eventHandler.Name).Params(
			jen.Id("ctx").Qual("context", "Context"),
			jen.Id("event").Qual(eventHandler.Event.Package.Path, eventHandler.Event.Name),
		).Error(),
	).Line()

	code.Commentf("%s handles %s events.", eventHandlerTypeName, eventHandler.Name)
	code.Type().Id(eventHandlerTypeName).Struct(
		jen.Id(handlerVarName).Id(handlerTypeName),
		jen.Id(handlerNameVarName).String(),
	).Line()

	code.Commentf("New%s returns a new %s instance.", eventHandlerTypeName, eventHandlerTypeName)
	code.Func().
		Id("New"+eventHandlerTypeName).
		Params(
			jen.Id(handlerVarName).Id(handlerTypeName),
			jen.Id(handlerNameVarName).String(),
		).
		Id(eventHandlerTypeName).
		Block(
			jen.Return(
				jen.Id(eventHandlerTypeName).Values(jen.Dict{
					jen.Id(handlerVarName):     jen.Id(handlerVarName),
					jen.Id(handlerNameVarName): jen.Id(handlerNameVarName),
				}),
			),
		).
		Line()

	code.Comment("HandlerName returns the name of the event handler.")
	code.Func().
		Params(
			jen.Id("h").Id(eventHandlerTypeName),
		).
		Id("HandlerName").
		Params().
		Params(jen.String()).
		Block(jen.Return(jen.Id("h").Dot(handlerNameVarName)))

	code.Comment("NewEvent returns a new empty event used for serialization.")
	code.Func().
		Params(
			jen.Id("h").Id(eventHandlerTypeName),
		).
		Id("NewEvent").
		Params().
		Params(jen.Interface()).
		Block(jen.Return(jen.Op("&").Qual(eventHandler.Event.Package.Path, eventHandler.Event.Name).Values()))

	code.Comment("Handle handles an event.")
	code.Func().
		Params(
			jen.Id("h").Id(eventHandlerTypeName),
		).
		Id("Handle").
		Params(
			jen.Id("ctx").Qual("context", "Context"),
			jen.Id("event").Interface(),
		).
		Params(jen.Error()).
		Block(
			jen.List(jen.Id("e"), jen.Id("ok")).
				Op(":=").
				Id("event").
				Assert(jen.Op("*").Qual(eventHandler.Event.Package.Path, eventHandler.Event.Name)),
			jen.If(jen.Op("!").Id("ok")).Block(
				jen.Return(
					jen.Qual("emperror.dev/errors", "NewWithDetails").Call(
						jen.Lit("unexpected event type"),
						jen.Lit("type"),
						jen.Qual("fmt", "Sprintf").Call(
							jen.Lit("%T"),
							jen.Id("event"),
						),
					),
				),
			),
			jen.Line(),
			jen.Return(
				jen.Id("h").Dot(handlerVarName).Dot(eventHandler.Name).Call(
					jen.Id("ctx"),
					jen.Op("*").Id("e"),
				),
			),
		)
}
