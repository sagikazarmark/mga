package endpoint

import (
	"bytes"
	"fmt"
	"go/format"
	"go/types"
	"strings"

	"github.com/dave/jennifer/jen"

	"sagikazarmark.dev/mga/pkg/gentypes"
	"sagikazarmark.dev/mga/pkg/jenutils"
)

// File represents one or more services and provides information for generating endpoints for these services.
type File struct {
	gentypes.File

	// EndpointSets represents endpoints to be generated for each service in the package.
	EndpointSets []EndpointSet
}

// EndpointSet represents a set of endpoints for a single service.
// nolint: golint
type EndpointSet struct {
	Service Service

	// ModuleName can be used instead of the package name in an operation name to uniquely identify a service call.
	//
	// Falls back to the package name.
	ModuleName string

	// WithOpenCensus enables generating a trace middleware for the endpoint set.
	WithOpenCensus bool

	// ErrorStrategy decides whether returned errors are checked for being endpoint or service errors.
	ErrorStrategy string
}

// Service represents a service interface.
type Service struct {
	Object *types.TypeName
	Type   *types.Interface
}

// Generate generates Go kit endpoint sets for services.
func Generate(file File) ([]byte, error) {
	code := jen.NewFilePathName(file.Package.Path, file.Package.Name)

	code.HeaderComment("//go:build !ignore_autogenerated\n// +build !ignore_autogenerated\n")

	if file.HeaderText != "" {
		code.HeaderComment(file.HeaderText)
	}

	code.HeaderComment("Code generated by mga tool. DO NOT EDIT.")

	code.ImportName("github.com/go-kit/kit/endpoint", "endpoint")
	code.ImportAlias("github.com/sagikazarmark/kitx/endpoint", "kitxendpoint")

	code.Comment("endpointError identifies an error that should be returned as an endpoint error.")
	code.Type().Id("endpointError").Interface(
		jen.Id("EndpointError").Params().Bool(),
	)

	code.Comment("serviceError identifies an error that should be returned as a service error.")
	code.Type().Id("serviceError").Interface(
		jen.Id("ServiceError").Params().Bool(),
	)

	for _, set := range file.EndpointSets {
		generateEndpointSet(code, set)
	}

	var buf bytes.Buffer

	err := code.Render(&buf)
	if err != nil {
		return nil, err
	}

	return format.Source(buf.Bytes())
}

// nolint: gocognit
func generateEndpointSet(code *jen.File, set EndpointSet) {
	svc := set.Service

	// import the service package
	code.ImportName(svc.Object.Pkg().Path(), svc.Object.Pkg().Name())

	name := strings.TrimSuffix(svc.Object.Name(), "Service")

	moduleName := set.ModuleName
	if moduleName == "" {
		moduleName = svc.Object.Pkg().Name()
	}

	endpointSetName := fmt.Sprintf("%sEndpoints", name)
	endpointSetFactoryName := fmt.Sprintf("Make%sEndpoints", name)
	endpointSetTraceFactoryName := fmt.Sprintf("Trace%sEndpoints", name)

	endpointSetFields := make([]jen.Code, 0, svc.Type.NumMethods())
	endpointSetDict := jen.Dict{}
	endpointSetTraceDict := jen.Dict{}
	endpoints := make([]jen.Code, 0, svc.Type.NumMethods()*6) // request, response, factory + comments

	for i := 0; i < svc.Type.NumMethods(); i++ {
		method := svc.Type.Method(i)

		endpointName := method.Name()

		var operationName string
		if name == "" {
			operationName = fmt.Sprintf("%s.%s", moduleName, endpointName)
		} else {
			operationName = fmt.Sprintf("%s.%s.%s", moduleName, name, endpointName)
		}

		// Ignore unexported methods
		if !method.Exported() {
			continue
		}

		endpointFactoryName := fmt.Sprintf("Make%s%sEndpoint", endpointName, name)

		endpointSetFields = append(endpointSetFields, jen.Id(endpointName).Qual("github.com/go-kit/kit/endpoint", "Endpoint"))
		endpointSetDict[jen.Id(endpointName)] = jen.Qual("github.com/sagikazarmark/kitx/endpoint", "OperationNameMiddleware").
			Call(jen.Lit(operationName)).
			Call(
				jen.Id("mw").Call(
					jen.Id(endpointFactoryName).Call(jen.Id("service")),
				),
			)

		if set.WithOpenCensus {
			endpointSetTraceDict[jen.Id(endpointName)] = jen.Qual(
				"github.com/go-kit/kit/tracing/opencensus",
				"TraceEndpoint",
			).
				Call(jen.Lit(operationName)).
				Call(jen.Id("endpoints").Dot(endpointName))
		}

		sig := method.Type().(*types.Signature)

		requestName := fmt.Sprintf("%s%sRequest", endpointName, name)
		responseName := fmt.Sprintf("%s%sResponse", endpointName, name)

		var callParams []jen.Code
		returnValues := &jen.Statement{}
		responseDict := jen.Dict{}
		responseErrorDict := jen.Dict{}

		{
			numParams := sig.Params().Len()
			fields := make([]jen.Code, 0, numParams)

			for i := 1; i < numParams; i++ {
				param := sig.Params().At(i)

				name := param.Name()
				if name == "" {
					name = fmt.Sprintf("p%d", i-1)
				}

				name = jenutils.Export(name)

				fields = append(fields, jenutils.Type(jen.Id(name), param.Type()))
				callParams = append(callParams, jen.Id("req").Dot(name))
			}

			endpoints = append(
				endpoints,
				jen.Commentf("%s is a request struct for %s endpoint.", requestName, endpointName),
				jen.Type().Id(requestName).Struct(fields...),
			)
		}

		{
			numResults := sig.Results().Len()
			fields := make([]jen.Code, 0, numResults)

			for i := 0; i < numResults-1; i++ {
				result := sig.Results().At(i)

				name := result.Name()
				if name == "" {
					name = fmt.Sprintf("r%d", i)
				}

				fieldName := jenutils.Export(name)
				varName := jenutils.Unexport(name)

				fields = append(fields, jenutils.Type(jen.Id(fieldName), result.Type()))
				returnValues.Id(varName).Op(",")

				responseDict[jen.Id(fieldName)] = jen.Id(varName)
				responseErrorDict[jen.Id(fieldName)] = jen.Id(varName)
			}

			fields = append(fields, jen.Id("Err").Error())
			returnValues.Err()
			responseErrorDict[jen.Id("Err")] = jen.Err()

			endpoints = append(
				endpoints,
				jen.Commentf("%s is a response struct for %s endpoint.", responseName, endpointName),
				jen.Type().Id(responseName).Struct(fields...),
				jen.Func().Params(
					jen.Id("r").Id(responseName),
				).Id("Failed").Params().Error().Block(
					jen.Return(jen.Id("r").Dot("Err")),
				),
			)
		}

		endpoints = append(
			endpoints,
			jen.Commentf("%s returns an endpoint for the matching method of the underlying service.", endpointFactoryName),
			jen.Func().Id(endpointFactoryName).
				Params(jen.Id("service").Qual(svc.Object.Pkg().Path(), svc.Object.Name())).
				Params(jen.Qual("github.com/go-kit/kit/endpoint", "Endpoint")).
				Block(
					jen.Return(
						jen.Func().
							Params(
								jen.Id("ctx").Qual("context", "Context"),
								jen.Id("request").Interface(),
							).
							Params( // named return parameter causes trouble when there are no result parameters (err: no new parameters)
								jen.Interface(),
								jen.Error(),
							).
							Block(
								jen.Do(func(s *jen.Statement) {
									if len(callParams) > 0 {
										s.Id("req").Op(":=").Id("request").Assert(jen.Id(requestName))
										s.Line()
									}
								}),
								returnValues.Op(":=").Id("service").Dot(endpointName).Call(
									append([]jen.Code{jen.Id("ctx")}, callParams...)...,
								),
								jen.Line(),
								jen.If(jen.Err().Op("!=").Nil()).Block(
									jen.Do(func(s *jen.Statement) {
										if strategy := strings.ToLower(set.ErrorStrategy); strategy == "service" {
											s.If(
												jen.Id("serviceErr").Op(":=").Id("serviceError").Parens(jen.Nil()),
												jen.Qual("errors", "As").Call(
													jen.Err(),
													jen.Op("&").Id("serviceErr"),
												).Op("&&").Id("serviceErr").Dot("ServiceError").Call(),
											).Block(
												jen.Return(
													jen.Id(responseName).Values(responseErrorDict),
													jen.Nil(),
												),
											).Line()

											s.Line()
											s.Return(
												jen.Id(responseName).Values(responseErrorDict),
												jen.Err(),
											)
										} else {
											s.If(
												jen.Id("endpointErr").Op(":=").Id("endpointError").Parens(jen.Nil()),
												jen.Qual("errors", "As").Call(
													jen.Err(),
													jen.Op("&").Id("endpointErr"),
												).Op("&&").Id("endpointErr").Dot("EndpointError").Call(),
											).Block(
												jen.Return(
													jen.Id(responseName).Values(responseErrorDict),
													jen.Err(),
												),
											).Line()

											s.Line()
											s.Return(
												jen.Id(responseName).Values(responseErrorDict),
												jen.Nil(),
											)
										}
									}),
								),
								jen.Line(),
								jen.Return(
									jen.Id(responseName).Values(responseDict),
									jen.Nil(),
								),
							),
					),
				),
		)
	}

	code.Commentf("%s collects all of the endpoints that compose the underlying service. It's", endpointSetName)
	code.Comment("meant to be used as a helper struct, to collect all of the endpoints into a")
	code.Comment("single parameter.")
	code.Type().Id(endpointSetName).Struct(endpointSetFields...)

	code.Commentf("%s returns a(n) %s struct where each endpoint invokes", endpointSetFactoryName, endpointSetName)
	code.Comment("the corresponding method on the provided service.")
	code.Func().Id(endpointSetFactoryName).
		Params(
			jen.Id("service").Qual(svc.Object.Pkg().Path(), svc.Object.Name()),
			jen.Id("middleware").Op("...").Qual("github.com/go-kit/kit/endpoint", "Middleware"),
		).
		Params(jen.Id(endpointSetName)).
		BlockFunc(func(code *jen.Group) {
			var mw *jen.Statement
			if len(endpoints) == 0 {
				mw = code.Id("_").Op("=")
			} else {
				mw = code.Id("mw").Op(":=")
			}

			mw.Qual("github.com/sagikazarmark/kitx/endpoint", "Combine").
				Call(jen.Id("middleware").Op("..."))

			code.Line()

			code.Return(
				jen.Id(endpointSetName).Values(endpointSetDict),
			)
		})

	if set.WithOpenCensus {
		code.ImportAlias("github.com/go-kit/kit/tracing/opencensus", "kitoc")

		code.Commentf(
			"%s returns a(n) %s struct where each endpoint is wrapped with a tracing middleware.",
			endpointSetTraceFactoryName,
			endpointSetName,
		)
		code.Func().Id(endpointSetTraceFactoryName).
			Params(jen.Id("endpoints").Id(endpointSetName)).
			Params(jen.Id(endpointSetName)).
			Block(jen.Return(jen.Id(endpointSetName).Values(endpointSetTraceDict)))
	}

	for _, endpointCode := range endpoints {
		code.Add(endpointCode)
	}
}
