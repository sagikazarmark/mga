package mock

import (
	"bytes"
	"fmt"
	"go/format"
	"go/types"

	"github.com/dave/jennifer/jen"

	"sagikazarmark.dev/mga/pkg/gentypes"
	"sagikazarmark.dev/mga/pkg/jenutils"
)

// File represents one or more interfaces and provides information for generating mocks for these interfaces.
type File struct {
	gentypes.File

	// Interfaces represents the interfaces that needs to be mocked.
	Interfaces []Interface
}

// Interface represents an interface.
type Interface struct {
	Object *types.TypeName
	Type   *types.Interface
}

// Generate generates Go kit endpoint sets for services.
func Generate(file File) ([]byte, error) {
	code := jen.NewFilePathName(file.Package.Path, file.Package.Name)

	code.HeaderComment("//go:build !ignore_autogenerated\n// +build !ignore_autogenerated\n")

	if file.HeaderText != "" {
		code.HeaderComment(file.HeaderText)
	}

	code.HeaderComment("Code generated by mga tool. DO NOT EDIT.")

	code.ImportName("github.com/stretchr/testify/mock", "mock")

	for _, iface := range file.Interfaces {
		generateMock(code, iface)
	}

	var buf bytes.Buffer

	err := code.Render(&buf)
	if err != nil {
		return nil, err
	}

	return format.Source(buf.Bytes())
}

// nolint: gocognit
func generateMock(code *jen.File, iface Interface) {
	// import the interface package
	code.ImportName(iface.Object.Pkg().Path(), iface.Object.Pkg().Name())

	mockName := fmt.Sprintf("Mock%s", iface.Object.Name())

	code.Commentf("Mock%[1]s is an autogenerated mock for the %[1]s type.", iface.Object.Name())
	code.Type().Id(mockName).Struct(
		jen.Qual("github.com/stretchr/testify/mock", "Mock"),
	)

	for i := 0; i < iface.Type.NumMethods(); i++ {
		method := iface.Type.Method(i)

		sig := method.Type().(*types.Signature)
		isVariadicFunction := sig.Variadic()

		const recv = "_m"
		const varParamName = "varParam"
		const varParamsName = "varParams"
		const varIndexName = "varIndex"
		const unnamedParameterPrefix = "_parameter_"
		const unnamedResultPrefix = "_result_"

		code.Commentf("%s provides a mock function.", method.Name())
		code.Func().
			Params(jen.Id(recv).Op("*").Id(mockName)).
			Id(method.Name()).
			ParamsFunc(func(group *jen.Group) {
				params := sig.Params()

				for i := 0; i < params.Len(); i++ {
					param := params.At(i)

					paramName := param.Name()
					if paramName == "" {
						paramName = fmt.Sprintf("%s%d", unnamedParameterPrefix, i)
					}

					paramNameStatement := group.Id(paramName)
					paramType := param.Type()
					if isVariadicFunction &&
						i == params.Len()-1 {
						// Note: variadic type is received as []Type, but should
						// be generated as ...Type function parameter.
						paramNameStatement = paramNameStatement.Op("...")
						sliceType := paramType.(*types.Slice)
						paramType = sliceType.Elem()
					}

					jenutils.Import(code, paramType)
					jenutils.Type(paramNameStatement, paramType)
				}
			}).
			ParamsFunc(func(group *jen.Group) {
				results := sig.Results()

				for i := 0; i < results.Len(); i++ {
					result := results.At(i)
					resultName := result.Name()
					if resultName == "" {
						resultName = fmt.Sprintf("%s%d", unnamedResultPrefix, i)
					}

					jenutils.Import(code, result.Type())
					jenutils.Type(group.Id(resultName), result.Type())
				}
			}).
			BlockFunc(func(group *jen.Group) {
				results := sig.Results()

				params := sig.Params()
				var assertParams []jen.Code
				var callParams []jen.Code

				if isVariadicFunction {
					paramName := params.At(params.Len() - 1).Name()
					if paramName == "" {
						paramName = fmt.Sprintf("%s%d", unnamedParameterPrefix, params.Len()-1)
					}

					group.Id(varParamsName).Op(":=").Make(
						jen.List(
							jen.Index().Add(jen.Interface()),
							jen.Op(fmt.Sprintf("%d+len(%s)", params.Len()-1, paramName)),
						),
					)
				}

				for i := 0; i < params.Len(); i++ {
					param := params.At(i)

					paramName := param.Name()
					if paramName == "" {
						paramName = fmt.Sprintf("%s%d", unnamedParameterPrefix, i)
					}

					paramNameStatement := jen.Id(paramName)
					paramType := param.Type()
					paramTypeStatement := &jen.Statement{}
					if isVariadicFunction &&
						i == params.Len()-1 {
						// Note: variadic type is received as []Type, but should
						// be generated as ...Type function parameter and value... argument.
						paramNameStatement = paramNameStatement.Op("...")
						paramTypeStatement = paramTypeStatement.Op("...")
						sliceType := paramType.(*types.Slice)
						paramType = sliceType.Elem()
					}

					assertParams = append(assertParams, jenutils.Type(paramTypeStatement, paramType))
					callParams = append(callParams, paramNameStatement)

					if isVariadicFunction {
						if i < params.Len()-1 {
							group.Id(varParamsName).Index(jen.Op(fmt.Sprintf("%d", i))).Op("=").Id(paramName)
						} else {
							group.For(jen.List(jen.Id(varIndexName), jen.Id(varParamName))).Op(":=").Range().Id(paramName).Block(
								jen.Id(varParamsName).Index(jen.Op(fmt.Sprintf("%d+%s", i, varIndexName))).Op("=").Id(varParamName),
							)
						}
					}
				}

				calledParams := callParams
				if isVariadicFunction {
					group.Line()
					calledParams = []jen.Code{
						jen.Id(varParamsName).Op("..."),
					}
				}

				if results.Len() == 0 {
					group.Id(recv).Dot("Called").Call(calledParams...)

					return
				}

				group.Id("ret").Op(":=").Id(recv).Dot("Called").Call(calledParams...)
				group.Line()

				var returns []jen.Code

				for i := 0; i < results.Len(); i++ {
					i := i

					result := results.At(i)

					r := fmt.Sprintf("r%d", i)
					returns = append(returns, jen.Id(r))

					jenutils.Type(group.Var().Id(r), result.Type())

					group.If(
						jen.Id("rf").Op(",").Id("ok").
							Op(":=").
							Id("ret").Dot("Get").Call(jen.Lit(i)).
							Assert(jen.Func().Params(assertParams...).Params(jenutils.Type(&jen.Statement{}, result.Type()))),
						jen.Id("ok"),
					).Block(
						jen.Id(r).Op("=").Id("rf").Call(callParams...),
					).Else().BlockFunc(func(group *jen.Group) {
						// TODO: find a better way to determine if a type represents an error
						if result.Type().String() == "error" {
							group.Id(r).Op("=").Id("ret").Dot("Error").Call(jen.Lit(i))
						} else {
							retValCode := jen.Id(r).Op("=").Id("ret").Dot("Get").Call(jen.Lit(i)).
								Assert(jenutils.Type(&jen.Statement{}, result.Type()))

							if jenutils.IsNillable(result.Type()) {
								group.If(jen.Id("ret").Dot("Get").Call(jen.Lit(i)).Op("!=").Nil()).Block(retValCode)
							} else {
								group.Add(retValCode)
							}
						}
					})

					group.Line()
				}

				group.Return(returns...)
			}).
			Line()
	}
}
